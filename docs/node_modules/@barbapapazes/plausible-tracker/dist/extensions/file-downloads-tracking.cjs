"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.defaultFileTypes = void 0;
exports.useAutoFileDownloadsTracking = useAutoFileDownloadsTracking;
var _utils = require("./utils.cjs");
const defaultFileTypes = exports.defaultFileTypes = ["pdf", "xlsx", "docx", "txt", "rtf", "csv", "exe", "key", "pps", "ppt", "pptx", "7z", "pkg", "rar", "gz", "zip", "avi", "mov", "mp4", "mpeg", "wmv", "midi", "mp3", "wav", "wma"];
function useAutoFileDownloadsTracking(plausible, extensionOptions, initOptions) {
  const fileTypes = extensionOptions.fileTypes;
  const options = {
    ...initOptions
  };
  const tracked = /* @__PURE__ */new Set();
  function setEventOptions(newOptions) {
    Object.assign(options, newOptions);
  }
  function handleLinkClickEvent(event) {
    if (event.type === "auxclick" && event.button !== 1) return;
    const pathname = this.pathname;
    if (!isDownloadToTrack(pathname, fileTypes)) return;
    let followedLink = false;
    const followLink = () => {
      if (!followedLink) {
        followedLink = true;
        (0, _utils.openLink)(this);
      }
    };
    const props = {
      url: pathname
    };
    if ((0, _utils.shouldFollowLink)(event, this)) {
      plausible.trackEvent("File Download", {
        props,
        callback: followLink
      });
      setTimeout(followLink, 1e3);
      event.preventDefault();
    } else {
      plausible.trackEvent("File Download", {
        props
      });
    }
  }
  function addNode(node) {
    if (node instanceof HTMLAnchorElement) {
      if (node.host === location.host) {
        node.addEventListener("click", handleLinkClickEvent);
        node.addEventListener("auxclick", handleLinkClickEvent);
        tracked.add(node);
      }
    } else if ("querySelectorAll" in node) {
      node.querySelectorAll("a").forEach(addNode);
    }
  }
  function removeNode(node) {
    if (node instanceof HTMLAnchorElement) {
      node.removeEventListener("click", handleLinkClickEvent);
      node.removeEventListener("auxclick", handleLinkClickEvent);
      tracked.delete(node);
    } else if ("querySelectorAll" in node) {
      node.querySelectorAll("a").forEach(removeNode);
    }
  }
  const observer = new MutationObserver(mutations => {
    mutations.forEach(mutation => {
      if (mutation.type === "attributes") {
        removeNode(mutation.target);
        addNode(mutation.target);
      } else if (mutation.type === "childList") {
        mutation.addedNodes.forEach(addNode);
        mutation.removedNodes.forEach(removeNode);
      }
    });
  });
  function install() {
    const targetNode = document;
    const observerInit = {
      subtree: true,
      childList: true,
      attributes: true,
      attributeFilter: ["href"]
    };
    targetNode.querySelectorAll("a").forEach(addNode);
    observer.observe(targetNode, observerInit);
  }
  function cleanup() {
    tracked.forEach(a => {
      a.removeEventListener("click", handleLinkClickEvent);
      a.removeEventListener("auxclick", handleLinkClickEvent);
    });
    tracked.clear();
    observer.disconnect();
  }
  ;
  return {
    install,
    cleanup,
    setEventOptions
  };
}
function isDownloadToTrack(url, fileTypes) {
  if (!url) return false;
  const fileType = url.split(".").pop();
  if (!fileType) return false;
  return fileTypes.includes(fileType);
}